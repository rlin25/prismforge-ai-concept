# GitLab CI/CD Pipeline for PrismForge AI Enterprise
stages:
  - security
  - test
  - build
  - deploy-staging
  - deploy-production
  - monitor

variables:
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  NODE_VERSION: "18"
  POSTGRES_DB: prismforge_test
  POSTGRES_USER: postgres
  POSTGRES_PASSWORD: postgres
  REDIS_URL: redis://redis:6379
  KUBECONFIG: /tmp/kubeconfig

# Security and code quality stage
security:semgrep:
  stage: security
  image: returntocorp/semgrep:latest
  script:
    - semgrep --config=auto --json --output=semgrep-results.json .
  artifacts:
    reports:
      sast: semgrep-results.json
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

security:container-scan:
  stage: security
  image: docker:stable
  services:
    - docker:dind
  before_script:
    - apk add --no-cache curl
    - curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b /usr/local/bin
  script:
    - docker build -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA .
    - trivy image --format template --template "@contrib/sarif.tpl" -o trivy-results.sarif $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
  artifacts:
    reports:
      sast: trivy-results.sarif
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

security:dependency-scan:
  stage: security
  image: node:$NODE_VERSION
  script:
    - npm ci --audit
    - npm audit --audit-level high --json > npm-audit.json
  artifacts:
    reports:
      dependency_scanning: npm-audit.json
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

# Test stage
test:unit:
  stage: test
  image: node:$NODE_VERSION
  services:
    - postgres:15
    - redis:7
  variables:
    DATABASE_URL: postgresql://postgres:postgres@postgres:5432/prismforge_test
  before_script:
    - npm ci
    - cp .env.test.example .env.test
  script:
    - npm run typecheck
    - npm run lint
    - npm run test:unit -- --coverage --passWithNoTests
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
      junit: junit.xml
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

test:integration:
  stage: test
  image: node:$NODE_VERSION
  services:
    - postgres:15
    - redis:7
  variables:
    DATABASE_URL: postgresql://postgres:postgres@postgres:5432/prismforge_test
  before_script:
    - npm ci
    - cp .env.test.example .env.test
    - npm run db:migrate:test
  script:
    - npm run test:integration -- --passWithNoTests
  artifacts:
    reports:
      junit: junit.xml
    expire_in: 1 week
  rules:
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
    - if: '$CI_COMMIT_BRANCH == "main"'

test:e2e:
  stage: test
  image: cypress/included:latest
  services:
    - postgres:15
    - redis:7
  variables:
    DATABASE_URL: postgresql://postgres:postgres@postgres:5432/prismforge_test
    CYPRESS_baseUrl: http://localhost:3000
  before_script:
    - npm ci
    - cp .env.test.example .env.test
    - npm run build
    - npm start &
    - npx wait-on http://localhost:3000
  script:
    - npm run test:e2e
  artifacts:
    when: always
    paths:
      - cypress/screenshots/
      - cypress/videos/
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'

# Build stage
build:image:
  stage: build
  image: docker:stable
  services:
    - docker:dind
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - |
      if [[ "$CI_COMMIT_BRANCH" == "main" ]]; then
        TAG="latest"
      elif [[ "$CI_COMMIT_TAG" ]]; then
        TAG="$CI_COMMIT_TAG"
      else
        TAG="$CI_COMMIT_REF_SLUG"
      fi
    - docker build 
        --build-arg BUILD_DATE=$(date -u +'%Y-%m-%dT%H:%M:%SZ')
        --build-arg VCS_REF=$CI_COMMIT_SHA
        --build-arg VERSION=$TAG
        -t $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
        -t $CI_REGISTRY_IMAGE:$TAG
        .
    - docker push $CI_REGISTRY_IMAGE:$CI_COMMIT_SHA
    - docker push $CI_REGISTRY_IMAGE:$TAG
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

build:helm:
  stage: build
  image: alpine/helm:latest
  script:
    - helm package ./helm/prismforge-ai --version $CI_COMMIT_SHA
    - helm push prismforge-ai-$CI_COMMIT_SHA.tgz oci://$CI_REGISTRY/helm
  artifacts:
    paths:
      - "*.tgz"
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG'

# Deploy staging
deploy:staging:
  stage: deploy-staging
  image: alpine/k8s:latest
  environment:
    name: staging
    url: https://staging.prismforge-ai.example.com
  before_script:
    - echo $KUBE_CONFIG_STAGING | base64 -d > $KUBECONFIG
    - helm repo add prismforge-ai oci://$CI_REGISTRY/helm
  script:
    - |
      helm upgrade --install prismforge-ai-staging oci://$CI_REGISTRY/helm/prismforge-ai --version $CI_COMMIT_SHA \
        --namespace prismforge-ai-staging \
        --create-namespace \
        --set image.repository=$CI_REGISTRY_IMAGE \
        --set image.tag=$CI_COMMIT_SHA \
        --set ingress.hosts[0].host=staging.prismforge-ai.example.com \
        --set environment=staging \
        --values ./helm/prismforge-ai/values-staging.yaml \
        --wait --timeout=10m
    - kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=prismforge-ai -n prismforge-ai-staging --timeout=300s
    - npm run test:smoke -- --baseUrl=https://staging.prismforge-ai.example.com
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'

# Deploy production (manual)
deploy:production:
  stage: deploy-production
  image: alpine/k8s:latest
  environment:
    name: production
    url: https://prismforge-ai.example.com
  when: manual
  only:
    - main
    - tags
  before_script:
    - echo $KUBE_CONFIG_PRODUCTION | base64 -d > $KUBECONFIG
    - helm repo add prismforge-ai oci://$CI_REGISTRY/helm
  script:
    # Create backup
    - kubectl exec -n prismforge-ai deployment/postgres -- pg_dump -U postgres prismforge > backup-$(date +%Y%m%d-%H%M%S).sql
    
    # Blue-Green deployment
    - |
      # Deploy green version
      helm upgrade --install prismforge-ai-green oci://$CI_REGISTRY/helm/prismforge-ai --version $CI_COMMIT_SHA \
        --namespace prismforge-ai \
        --set image.repository=$CI_REGISTRY_IMAGE \
        --set image.tag=$CI_COMMIT_SHA \
        --set ingress.hosts[0].host=green.prismforge-ai.example.com \
        --set environment=production \
        --set replicaCount=3 \
        --set version=green \
        --values ./helm/prismforge-ai/values-production.yaml \
        --wait --timeout=15m
      
      # Health check green environment
      kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=prismforge-ai,version=green -n prismforge-ai --timeout=600s
      npm run test:health -- --baseUrl=https://green.prismforge-ai.example.com
      
      # Switch traffic to green
      kubectl patch service prismforge-ai-app -n prismforge-ai -p '{"spec":{"selector":{"version":"green"}}}'
      
      # Verify production
      sleep 30
      npm run test:smoke -- --baseUrl=https://prismforge-ai.example.com
      
      # Clean up old blue deployment
      helm uninstall prismforge-ai-blue -n prismforge-ai || true
  after_script:
    - |
      if [ "$CI_JOB_STATUS" != "success" ]; then
        echo "Deployment failed, rolling back..."
        kubectl patch service prismforge-ai-app -n prismforge-ai -p '{"spec":{"selector":{"version":"blue"}}}' || true
        helm rollback prismforge-ai-green -n prismforge-ai || true
      fi

# Performance testing
performance:k6:
  stage: monitor
  image: grafana/k6:latest
  script:
    - k6 run --out json=results.json tests/performance/load-test.js
  artifacts:
    reports:
      performance: results.json
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
  needs:
    - deploy:staging

# Monitoring and alerting
monitor:setup:
  stage: monitor
  image: alpine/k8s:latest
  before_script:
    - echo $KUBE_CONFIG_PRODUCTION | base64 -d > $KUBECONFIG
  script:
    - kubectl apply -f monitoring/prometheus/
    - kubectl apply -f monitoring/grafana/
    - kubectl apply -f monitoring/alertmanager/
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      changes:
        - monitoring/**/*
  when: manual

# Notifications
notification:slack:
  stage: .post
  image: alpine:latest
  before_script:
    - apk add --no-cache curl jq
  script:
    - |
      if [ "$CI_JOB_STATUS" == "success" ]; then
        COLOR="good"
        STATUS="✅ Success"
      else
        COLOR="danger"
        STATUS="❌ Failed"
      fi
      
      PAYLOAD=$(jq -n --arg text "PrismForge AI Deployment" \
                    --arg color "$COLOR" \
                    --arg status "$STATUS" \
                    --arg branch "$CI_COMMIT_BRANCH" \
                    --arg commit "$CI_COMMIT_SHA" \
                    --arg url "$CI_PIPELINE_URL" \
                    '{
                      text: $text,
                      attachments: [{
                        color: $color,
                        fields: [
                          {title: "Status", value: $status, short: true},
                          {title: "Branch", value: $branch, short: true},
                          {title: "Commit", value: $commit, short: true},
                          {title: "Pipeline", value: $url, short: false}
                        ]
                      }]
                    }')
      
      curl -X POST -H 'Content-type: application/json' \
           --data "$PAYLOAD" \
           "$SLACK_WEBHOOK_URL"
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
      when: always